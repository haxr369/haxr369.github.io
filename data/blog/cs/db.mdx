---
title: '[ASAC 스터디] Database'
date: 2024-04-17
lastmod: 2024-04-17
tags: ['CS', 'DB', 'lock', 'concurrency', 'acid', 'B-tree']
draft: false
summary: '운영체제 CS 정리'
---

## 목차

<TOCInline toc={props.toc} exclude="목차" toHeading={(2, 3)} />

ASAC 데이터베이스 면접 준비 스터디를 하면서 정리하는 글입니다.

### 데이터베이스에서 인덱스를 사용하는 이유 및 장단점에 대해 설명해주세요.

인덱스란 DB 내에서 존재하는 테이블의 부분 집합에 연결된 복사본입니다.
인덱스는 하나 이상의 컬럼으로 구성되어 있고, 테이블의 로우에 연결됩니다.

만약 인덱스가 없다면 쿼리를 수행하기 위해 DB는 테이블 전체를 돌면서 조건에 맞는 값을 찾아야합니다.
대신 인덱스가 있다면, 전체 테이블 대신 특정 열만 읽고 결과를 반환합니다.

하지만, 인덱스는 디스크에 공간을 차지하고, 테이블이 생성, 업데이트, 삭제가 일어나는 등 변화가 있을 때마다 동기화를 해야한다.
그렇기 때문에 업데이트가 빈법하게 일어나는 컬럼으로 인덱스를 만들면 안된다.

보통은 검색 조건이나 정렬 조건으로 사용되는 컬럼을 사용하고, 대부분의 RDBMS에서 기본키에는 인덱스가 자동 생성된다.
또한 외래 키 관계에서 참조되는 열은 다른 테이블의 열을 참조하며 자주 조회되는 대상이므로 인덱싱해야 합니다.

인덱스 테이블에는 설정한 속성 값과 그에 맞는 실제 테이블의 위치를 가리키는 포인터가 있다.
그리 인덱스를 생성할 때, 두개 이상 속성을 사용하면, 정렬할 때 왼쪽의 속성이 우선순위를 가진다. 그렇기에 멀티 컬럼 인덱스를 쓴다면 인덱스의 순서가 중요하다.

```sql
// player_name_idx라는 인덱스를 생성
// player를 테이블의 name 속성 이용
CREATE INDEX player_name_idx ON player (name);
```

```sql
// team_id_backnumber_idx라는 인덱스를 생성
// player를 테이블의 team_id, backnumber 속성을 이용함
CREATE UNIQUE INDEX team_id_backnumber_idx
  ON player (team_id, backnumber);
```

위의 경우 아래 같이 쿼리를 작성하면 정렬되지 않은 순서대로 검색하기 때문에 성능이 좋지 않다.

```sql
SELECT * FROM player WHERE backnumber=10;
SELECT * FROM player WHERE team_id=7 OR backnumber=10;
```

그 이유는 인덱스는 먼저 team_id를 기준으로 정렬하고 그 다음 backnumber로 정렬했기 때문에
backnumber만 놓고 보면 정렬되지 않고 뒤죽박죽인 상태다.
따라서 예제처럼 쿼리를 작성하려면 backnumber로 시작하는 인덱스를 생성할 필요가 있다.
그렇다면 어떤 쿼리를 보냈을 때, DB가 어떤 인덱스를 쓰는지 어떻게 알까? 쿼리를 보내기 전에 EXPLAIN을 붙여주면 되고, optimizer가 알아서 적절한 인덱스를 선택한다.
내가 선택하고 싶다면 아래처럼 쿼리를 작성하면 된다.

```sql
SELECT \* FROM player USE INDEX (team_id_backnumber_idx) WHERE teamn_id=10;
```

만약 특정 인덱스를 제외하고 싶다면 USE 대신 IGNORE를 사용하면된다.

### B-tree의 동작 방식

이진탐색트리는 부모 노드는 최대 두 자녀 노드를 가지는데 왼쪽 자녀 노드는 부모 노드 보다 작고, 오른쪽 자녀 노드는 부모 노드 보다 크다.
만약 자녀 노드를 3개로 하고 싶다면? 부모 노드의 크기가 2가 되어서 자녀 노드의 값 범위를 지정할 수 있다.
예를 들어 부모 노드 값 p1, p2가 있을 때, 왼쪽 자녀 노드는 p1 보다 작고, 가운데 자녀 노드는 p1과 p2 사이 값이고, 오른쪽 자녀 노드는 p2 보다 크게된다.
이렇게 자녀 노드의 개수를 2개 이상으로 늘릴 수 있는 트리를 B-tree라고 한다. 즉 B-tree는 이진탐색트리를 일반화한 것이라고 할 수 있다.

B-tree에서 중요한 파라미터인 최대 자녀 수를 M이라하고 보통 M차 B-tree라고 부른다.
최대 자녀 수만 정해지면 부모 노드의 최대 키 수는 M-1로 정해진다. 각 노드의 최소 자녀 수는 ROUNDUP(M/2)가 되지만, root 노드와 leaf 노드는 제외합니다.

B-tree에 데이터를 삽입하는 방식은 간단합니다.
leaf 노드에 데이터를 계속 추가하다가 최대 키 수인 M-1을 넘어가면 중앙 값을 부모 노드로 승격시키고, 좌우의 값들을 새로운 leaf 노드로 내려버립니다.

```sql
// 최대 자식 노드 개수 = 3
// 현재 상태
{"1", "2"}
// 15 추가 -> 중앙값 2를 부모노드로 승격, 나머지를 leaf 노드로 옮기기
          {"2" , ""}
{"1", ""}, {"15" , ""}, {"" , ""}
// 5 추가 -> leaf노드로 추가됨.
          {"2" , ""}
{"1", ""}, {"5" , "15"}, {"" , ""}
// 30 추가 -> {"5" , "15"} 로 30이 들어가는데 2를 초과하게 됨
// 중앙값인 15가 부모노드로 승격되고 30은 새로운 leaf로 들어감 -> 왜? 15보다 크기 때문이다.
          {"2" , "15"}
{"1", ""}, {"5" , ""}, {"30" , ""}
// 60과 90이 추가되면 오른쪽 leaf 노드가 M-1을 초과하게 되어 중앙값인 60이 부모노드로 추가
          {"2" , "15", "60"}
{"1", ""}, {"5" , ""}, {"30" , ""}, {"90" , ""}
// 그러나 부모 노드의 키 수도 M-1을 넘어갈 수 없기 때문에 다시 부모 노드의 중앙값인 15를 부모 노드로 승격시키고
// 나머지 2와 60을 분할한다.
                  {"15", ""}
      {"2", ""},              {"60", ""}
{"1", ""}, {"5", ""}      {"30", ""} , {"90", "}
```

위와 같은 방식으로 노드를 추가하면서 B-tree는 한쪽 트리만 깊어지는 이진트리의 불균형 문제를 해결합니다.
또한, 이런 방식으로 키 값을 추가하면 모든 leaf 노드는 같은 레벨에 있게됩니다.

### ACID에 대해서 설명해주세요.

트랜젝션은 여러 DB 작업들을 하나로 묶음 작업이며, All or Noting으로 결과가 나옵니다.
즉, 트랜젝션은 DB 데이터를 원하는 대로 업데이트되도록, 그렇지 않으면 업데이트 하지 않도록 해서 정합성을 유지하기 위해 사용됩니다.
ACID는 데이터 정합성을 유지하기 위한 트랜젝션의 특징입니다.

- Atomicity (원자성)

모든 작업이 All or Noting을 지키도록하는 원칙입니다.

- Consistency (정합성)

데이터가 미리 지정한 규칙으로만 수정할 수 있도록하는 원칙입니다. 또한 특정 row의 변화가 일어나면 그 row를 포함하는 모든 table에 그 변화가 적용되어야합니다.
그렇기 때문에 여러 DB로 테이블 복사본이 있을 때 테이블을 동기화할 수 있다면, Eventual Consistency라고 합니다.

- Isolation (고립성)

서로 다른 Transaction끼리 영향을 주면 안되는 것을 의미합니다. Transaction의 동작과 Transaction의 결과를 더럽히거나 무효화하게 된다면 격리되지 않는 것이라고 볼 수 있습니다.

- Durability (영구성)

DB system(ex pawer)에 문제가 생겨도 commit된 Transaction은 DB에 **영구적**으로 저장한다. 즉, `비휘발성 메모리`(HDD, SSD)에 저장함을 의미한다.
기본적으로 Transaction의 Durabilitysms DBMS가 보장한다.
