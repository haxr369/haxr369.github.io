---
title: '[ASAC 스터디] Database'
date: 2024-04-17
lastmod: 2024-04-17
tags: ['CS', 'DB', 'lock', 'concurrency', 'acid', 'B-tree']
draft: false
summary: '운영체제 CS 정리'
---

## 목차

<TOCInline toc={props.toc} exclude="목차" toHeading={(2, 3)} />

ASAC 데이터베이스 면접 준비 스터디를 하면서 정리하는 글입니다.

### 데이터베이스에서 인덱스를 사용하는 이유 및 장단점에 대해 설명해주세요.

인덱스란 DB 내에서 존재하는 테이블의 부분 집합에 연결된 복사본입니다.
인덱스는 하나 이상의 컬럼으로 구성되어 있고, 테이블의 로우에 연결됩니다.

만약 인덱스가 없다면 쿼리를 수행하기 위해 DB는 테이블 전체를 돌면서 조건에 맞는 값을 찾아야합니다.
대신 인덱스가 있다면, 전체 테이블 대신 특정 열만 읽고 결과를 반환합니다.

하지만, 인덱스는 디스크에 공간을 차지하고, 테이블이 생성, 업데이트, 삭제가 일어나는 등 변화가 있을 때마다 동기화를 해야한다.
그렇기 때문에 업데이트가 빈법하게 일어나는 컬럼으로 인덱스를 만들면 안된다.

보통은 검색 조건이나 정렬 조건으로 사용되는 컬럼을 사용하고, 대부분의 RDBMS에서 기본키에는 인덱스가 자동 생성된다.
또한 외래 키 관계에서 참조되는 열은 다른 테이블의 열을 참조하며 자주 조회되는 대상이므로 인덱싱해야 합니다.

인덱스 테이블에는 설정한 속성 값과 그에 맞는 실제 테이블의 위치를 가리키는 포인터가 있다.
그리 인덱스를 생성할 때, 두개 이상 속성을 사용하면, 정렬할 때 왼쪽의 속성이 우선순위를 가진다. 그렇기에 멀티 컬럼 인덱스를 쓴다면 인덱스의 순서가 중요하다.

```sql
// player_name_idx라는 인덱스를 생성
// player를 테이블의 name 속성 이용
CREATE INDEX player_name_idx ON player (name);
```

```sql
// team_id_backnumber_idx라는 인덱스를 생성
// player를 테이블의 team_id, backnumber 속성을 이용함
CREATE UNIQUE INDEX team_id_backnumber_idx
  ON player (team_id, backnumber);
```

위의 경우 아래 같이 쿼리를 작성하면 정렬되지 않은 순서대로 검색하기 때문에 성능이 좋지 않다.

```sql
SELECT * FROM player WHERE backnumber=10;
SELECT * FROM player WHERE team_id=7 OR backnumber=10;
```

그 이유는 인덱스는 먼저 team_id를 기준으로 정렬하고 그 다음 backnumber로 정렬했기 때문에
backnumber만 놓고 보면 정렬되지 않고 뒤죽박죽인 상태다.
따라서 예제처럼 쿼리를 작성하려면 backnumber로 시작하는 인덱스를 생성할 필요가 있다.
그렇다면 어떤 쿼리를 보냈을 때, DB가 어떤 인덱스를 쓰는지 어떻게 알까? 쿼리를 보내기 전에 EXPLAIN을 붙여주면 되고, optimizer가 알아서 적절한 인덱스를 선택한다.
내가 선택하고 싶다면 아래처럼 쿼리를 작성하면 된다.

```sql
SELECT \* FROM player USE INDEX (team_id_backnumber_idx) WHERE teamn_id=10;
```

만약 특정 인덱스를 제외하고 싶다면 USE 대신 IGNORE를 사용하면된다.

### B-tree의 동작 방식

이진탐색트리는 부모 노드는 최대 두 자녀 노드를 가지는데 왼쪽 자녀 노드는 부모 노드 보다 작고, 오른쪽 자녀 노드는 부모 노드 보다 크다.
만약 자녀 노드를 3개로 하고 싶다면? 부모 노드의 크기가 2가 되어서 자녀 노드의 값 범위를 지정할 수 있다.
예를 들어 부모 노드 값 p1, p2가 있을 때, 왼쪽 자녀 노드는 p1 보다 작고, 가운데 자녀 노드는 p1과 p2 사이 값이고, 오른쪽 자녀 노드는 p2 보다 크게된다.
이렇게 자녀 노드의 개수를 2개 이상으로 늘릴 수 있는 트리를 B-tree라고 한다. 즉 B-tree는 이진탐색트리를 일반화한 것이라고 할 수 있다.

B-tree에서 중요한 파라미터인 최대 자녀 수를 M이라하고 보통 M차 B-tree라고 부른다.
최대 자녀 수만 정해지면 부모 노드의 최대 키 수는 M-1로 정해진다. 각 노드의 최소 자녀 수는 ROUNDUP(M/2)가 되지만, root 노드와 leaf 노드는 제외합니다.

B-tree에 데이터를 삽입하는 방식은 간단합니다.
leaf 노드에 데이터를 계속 추가하다가 최대 키 수인 M-1을 넘어가면 중앙 값을 부모 노드로 승격시키고, 좌우의 값들을 새로운 leaf 노드로 내려버립니다.

```sql
// 최대 자식 노드 개수 = 3
// 현재 상태
{"1", "2"}
// 15 추가 -> 중앙값 2를 부모노드로 승격, 나머지를 leaf 노드로 옮기기
          {"2" , ""}
{"1", ""}, {"15" , ""}, {"" , ""}
// 5 추가 -> leaf노드로 추가됨.
          {"2" , ""}
{"1", ""}, {"5" , "15"}, {"" , ""}
// 30 추가 -> {"5" , "15"} 로 30이 들어가는데 2를 초과하게 됨
// 중앙값인 15가 부모노드로 승격되고 30은 새로운 leaf로 들어감 -> 왜? 15보다 크기 때문이다.
          {"2" , "15"}
{"1", ""}, {"5" , ""}, {"30" , ""}
// 60과 90이 추가되면 오른쪽 leaf 노드가 M-1을 초과하게 되어 중앙값인 60이 부모노드로 추가
          {"2" , "15", "60"}
{"1", ""}, {"5" , ""}, {"30" , ""}, {"90" , ""}
// 그러나 부모 노드의 키 수도 M-1을 넘어갈 수 없기 때문에 다시 부모 노드의 중앙값인 15를 부모 노드로 승격시키고
// 나머지 2와 60을 분할한다.
                  {"15", ""}
      {"2", ""},              {"60", ""}
{"1", ""}, {"5", ""}      {"30", ""} , {"90", "}
```

위와 같은 방식으로 노드를 추가하면서 B-tree는 한쪽 트리만 깊어지는 이진트리의 불균형 문제를 해결합니다.
또한, 이런 방식으로 키 값을 추가하면 모든 leaf 노드는 같은 레벨에 있게됩니다.

### ACID에 대해서 설명해주세요.

트랜젝션은 여러 DB 작업들을 하나로 묶음 작업이며, All or Noting으로 결과가 나옵니다.
즉, 트랜젝션은 DB 데이터를 원하는 대로 업데이트되도록, 그렇지 않으면 업데이트 하지 않도록 해서 정합성을 유지하기 위해 사용됩니다.
ACID는 데이터 정합성을 유지하기 위한 트랜젝션의 특징입니다.

- Atomicity (원자성)

모든 작업이 All or Noting을 지키도록하는 원칙입니다.

- Consistency (정합성)

데이터가 미리 지정한 규칙으로만 수정할 수 있도록하는 원칙입니다. 또한 특정 row의 변화가 일어나면 그 row를 포함하는 모든 table에 그 변화가 적용되어야합니다.
그렇기 때문에 여러 DB로 테이블 복사본이 있을 때 테이블을 동기화할 수 있다면, Eventual Consistency라고 합니다.

- Isolation (고립성)

서로 다른 Transaction끼리 영향을 주면 안되는 것을 의미합니다. Transaction의 동작과 Transaction의 결과를 더럽히거나 무효화하게 된다면 격리되지 않는 것이라고 볼 수 있습니다.

- Durability (영구성)

DB system(ex pawer)에 문제가 생겨도 commit된 Transaction은 DB에 **영구적**으로 저장한다. 즉, `비휘발성 메모리`(HDD, SSD)에 저장함을 의미한다.
기본적으로 Transaction의 Durabilitysms DBMS가 보장한다.

### 데이터베이스 정규화에 대해서 설명해주세요.

정규화는 관계형 데이터베이스에서 데이터의 중복을 최소화하게 데이터를 구조화하는 것입니다. 크고 조직되지 않은 테이블들을 작고 잘게 조직된 테이블과 관계로 나누는 것을 의미합니다.
정규화 단계는 많지만, 보통 3단계까지 정규화를 하면 정규화를 했다고 얘기를 합니다.

- 제 1 정규화 : 개별 테이블에서 반복되는 필드를 제거합니다. 기본 키로 각 데이터 집합을 식별합니다.
- 제 2 정규화 : 여러 레코드에 적용되는 값 집합에 대해 별도의 테이블을 만듭니다. 이러한 테이블을 외래키로 연관시킵니다.
- 제 3 정규화 : 기본 키에 의존하지 않는 필드를 제거합니다.

### 데이터베이스 join에 대해서 설명해주세요.

DB 정규화를 하면 테이블들을 분리시키고 데이터 중복을 최소화할 수 있습니다. 만약, 필요한 데이터가 서로 다른 테이블에 있다면 join을 통해서 각 테이블 데이터를 모아볼 수 있어야합니다.
서로 다른 테이블을 합치기 때문에 여러 방법이 있습니다.

`employees` 테이블과 `department` 테이블의 join 기준이 `ON employees_department_id = department_id` 인 상태를 가정하겠습니다.

- Inner join : 두 테이블의 교집합만 합치는 방법입니다. 둘 다 같은 id인 row가 결과로 나오게됩니다.
- Outter join : 두 테이블의 교집합이 아닌 값도 출력하는 방법입니다. Left outter join은 `employees_id`가 가질 수 있는 모든 경우에 대해서 결과로 나오게됩니다. 만약 오른쪽 테이블에서 공통된 값이 없다면 NULL을 반환하게됩니다.

Full Outter join과 Union의 차이는 Full Outter join은 두 테이블이 일치하지 않는 값도 결과에 포함시키지만, Union은 일치하는 값만 결과에 포함시킵니다.

### Mysql(InnoDB) 공유 락과 배타적 락, 갭 락 그리고 레코드 락을 설명해주세요

Mysql은 db 엔진으로 InnoDB를 사용합니다.

- InnoDB는 row-lock을 위해 공유락과 배차적락을 사용합니다.
  공유락은 Transaction이 row를 읽을 수 있도록 lock을 잡다둔겁니다. 베타락은 row를 업데이트하거나 제거하는데 사용합니다.

- 레코드 락
  레코드 락은 인덱스의 레코드에 락을 겁니다. 레코드 락에 걸린 인덱스에는 데이터 생성, 업데이트, 제거가 불가능해집니다.

- 갭 락
  레코드락은 하나의 인덱스 레코드에 락을 걸지만, 갭락은 인덱스 레코드에 범위로 락을 겁니다. 인덱스는 보통 기준 컬럼으로 정렬되어 있기 때문에 유효합니다.
