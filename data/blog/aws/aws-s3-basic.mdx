---
title: AWS S3 (1)
date: 2023-11-11
lastmod: 2023-11-11
tags: ['AWS', 'S3', 'DVA-C02']
draft: false
summary: 'AWS S3의 기본적인 개념 정리'
---

## 목차

<TOCInline toc={props.toc} exclude="목차" toHeading={(2, 3)} />

## 개요

S3는 AWS의 다양한 서비스와 연동해서 사용된다. 예를 들어 RDS 스냅샷이나 CodePipeline의 아티팩트를 저장하는 등 정적 파일을 저장할 때 자주 사용된다.

1. 백업이나 스토리지
2. 재해 복구용 : 한 Region에 문제가 생겨서 데이터를 백업할 때
3. 아카이브
4. 하이브리드 클라우드 스토리지 : 온프레미스 형식의 스토리지를 클라우드로 확장시킬 때
5. (static) 애플리케이션 호스팅 or 미디어 호스팅

위 사용사례말고도 더 많은 사용법이 있다. 실제로 나스닥은 7년치 데이터를 아카이브 용도로 S3 Glacier 서비스에 저장한다. Sysco는 S3로 데이터를 분석하고 비즈니스 인사이트를 얻는다.

## 버킷 (Buckets)

S3은 파일을 최상위 디렉터리 개념인 **버킷**에 저장하고, 파일은 **객체**로 관리된다. S3는 글로벌 리전이기 때문에 모든 계정, 모든 region의 모든 버킷의 이름은 고유해야한다.
그렇더라도 **버킷**은 특정 AWS **Region**에서 생성할 수 있다.

## 객체 (Object)

객체는 파일을 뜻하고 각 객체는 **키**(파일의 전체 경로)를 가지고 있다. 따라서 객체의 위치를 옮기면 경로인 키 값도 함께 변한다.

객체의 최대 크기는 5TB이며 매우 큰 파일(**5BG** 이상)을 **업로드**할 때는 **multi-part-upload**를 이용해서 파일을 여러 부분으로 나눠서 올려야한다.
따라서 5TB짜리를 업로드하려면 5GB짜리 1000개로 나누어 올려야한다.

또한 객체는 **키-값**의 리스트 형태인 메타데이터를 가질 수 있는데 시스템이나 유저가 설정할 수 있다. 메타데이터와 비슷하게 **태그**도 가질 수 있는데 최대 10개의 **키-값**을 가질 수 있다.
그리고 버저닝을 설정했다면 버전 ID를 가질 수 있다.

## 보안

S3는 다양한 방법으로 보안을 설정할 수 있다.

1. **유저 기반** : IAM 정책을 사용해서 어떤 **사용자**가 어떤 **API**를 호출할 수 있는지 정의
2. **자원 기반**
   - 버킷 정책 (Bucket Policies)는 S3 **콘솔**에서 버킷에 **다른 계정**이 **접근**할 수 있도록 허용 (계쩡 간 액세스 권한 위임) (AWS에서 대부분 사용하는 정책)
   - Object Access Control List (ACL) : 객체 액세스 제한 목록
   - Bucket Access Control List (ACL) : 버킷 단위 액세스 제한 목록

**IAM 사용자**는 **IAM 권한**에 접근이 **허용**돼 있거나 **자원 정책**에 해당 자원 접근이 **허용**돼 있을 때, 그리고 명시적 거부 액션이 없을 때 S3의 Object에 **접근 가능**하다.

또한 S3에 객체를 저장할 때 암호화 키를 이용해 객체를 암호화할 수 있다.

### Bucket Policies

```json:BucketPolicies.json
{
  "Version": "2012-10-17",
  "Id": "PutObjPolicy",
  "Statement": [
    {
      "Sid": "DenyObjectsThatAreNotSSEKMS",
      "Principal": "*",
      "Effect": "Deny",
      "Action": "s3:PutObject",
      "Resource": "arn:aws:s3:::DOC-EXAMPLE-BUCKET/*",
      "Condition": {
        "Null": {
          "s3:x-amz-server-side-encryption-aws-kms-key-id": "true"
        }
      }
    }
  ]
}
```

위 예제는 **모든 계정**에 대해서 **거부**한다. **PutObject**를 **DOC-EXAMPLE-BUCKET**에 대해서.

1. **Resource** : 정책이 적용되는 버킷 또는 객체
2. **Effect** : Action을 허용 혹은 거부
3. **Action** : Effect할 API를 작성
4. **Principal** : 정책을 적용할 IAM 유저나 계정을 명시

Bucket Policies를 통해서 버킷의 파블릭 접근을 할 수 있고, 객체를 업로드할 때 암호화를 강제할 수 있다. 그리고 다른 계정에게 접근 권한을 줄 수 있다.

IAM 유저가 S3에 접근할 때는 IAM 권한을 정의할 수 있고, EC2 같은 인스턴스가 S3에 접근할 때는 IAM 역할을 정의해서 접근할 수 있다.
IAM 유저는 권한, 인스턴스는 역할!

다른 계정의 IAM 유저가 사용하려면 먼저 버킷에 Cross-Account 권한을 명시해야한다

**Block Public Access**

AWS가 기업의 유출을 막기 위해 한 단계 추가로 덧씌운 보호막으로 S3를 퍼블릭으로 정책을 설정해도 이 설정이 활성화돼 있으면 버킷은 퍼블릭으로 공개되지 않는다.
이는 버킷을 생성할 때 설정하기 때문에 오직 **퍼블릭**으로 공개될 버킷만 설정한다.

### 정적 웹 사이트 호스팅

S3는 정적 파일을 호스팅하는 서비스기 때문에 HTML, CSS, JS 같은 정적인 파일을 클라이언트에게 보낼 수 있고 이는 웹 사이트 배포가 가능함을 의미한다.
당연하게 **퍼블릭** 공개가 돼야한다.

## 객체 버저닝 (Versioning)

S3에서 파일에 버전을 매길 수 있는데 버전 기능은 버킷 단위에서 설정해야한다. 누군가가 파일을 **업로드**하면 선택된 **키**로 해당 파일의 **버전**을 생성.
**동일**한 **키**로 파일을 다시 **업로드**하면 기존 파일을 덮어쓰는 것이 아니라 새로운 **버전**이 만들어진ㄷ.

버저닝을 하면 의도하지 않는 **삭제**를 방지할 수 있고, **이전 버전**으로 손쉽게 **롤백**할 수 있다.
또한 버저닝을 하기 전에 존재했던 객체들의 버전은 **null**로 설정된다.

## S3 복제 (Replication, SRR, CRR)

만약 서로 다른 Region에 존재하는 두 버킷을 **비동기** 복제를 동해 **동기화**를 하고 싶을 때, 소스 버킷과 대상 버킷 **둘 다 버저닝**을 활성화해야한다.
이처럼 두 버킷이 다른 Region에 있다면 Cross-Region Replication (CRR)이고, 동일한 Region에 있다면 Same-Region Replication (SRR)이 된다.

버킷은 서로 다른 계정이 소유해도 괜찮고, 비동기로 동기화되며 복제 작업은 백그라운드로 진행된다. 이를 위해선 대상 버킷에 읽고 쓰기가 가능하도록 S3에 IAM 권한을 부여해야한다.
S3 Replication 설정을 **활성화**한 다음 **생성**한 객체에 대해서 비동기 복제가 **가능**하다. **활성화 전**에 존재하던 **객체**는 **S3 Batch Replication**을 사용해야한다.
그리고 **delete marker**도 복제가 가능하지만, **영구 삭제**는 복사되지 않는다.
**chaining**도 지원되지 않는다. 버킷은 오직 한 버킷과만 동기화가 가능하다.

CRR은 기업 정책이나 저지연을 위해 사용하고 SRR은 로그 집계나 운영 계정과 테스트 게정 사이에서 라이브 복제할 대 유용하다.

## S3 스토리지 클래스 (Storage Classes)

S3에서 객체를 생성할 때 객체 클래스를 선택할 수 있다. S3에서 수동 설정할 수 있지만, S3 수명 주기에 따라 자동으로 객체의 클래스를 변경시킬 수 있다.

### 내구성(Durability) and 가용성(Availability)

내구성이란 S3가 얼마나 자주 객체를 잃느냐를 의미. 클래스 종류와 상관 없이 내구성은 동일하다.
가용성이란 서비스가 얼마나 사용 가능한지를 의미. 예를 들어 standard의 가용성인 99.99%는 1년에 53분 정도는 서비스를 이용할 수 없는 상태를 의미한다. 즉 365일 내내 서비스르 이용하다 53분 동안만 이용에 에러가 발생한다.

### 클래스 소개

S3 클래스들은 내구성은 전부 동일하기 때문에 비용과 내구성의 trade-off가 발생할 것이다.

- S3 Standard : General Purpose(99.99% 가용성) 자주 액세스하는 데이터를 저장. 거이 대부분의 상황에서 사용할 수 있다.
- S3 Standard-Infrequent Access(IA) : 99.9%의 가용성. 이름처럼 덜 자주 사용하는 데이터용. **standard** 보다는 비용이 **적지만** 데이터를 **조회**할 때 **비용**이 발생. 사용 목적은 **재해 복구용**
- S3 One Zone-Infrequent Access (One Zone-IA) : 오직 한 AZ(가용 영역)에서 사용 가능하고 매우 높은 내구성을 가진다. **One Zone**이기 때문에 그 **AZ**가 파괴되면 **데이터 손실**. 따라서 **가용성**은 99.5%로 더 낮다. 사용 목적은 **온프레미스 데이터**의 **백업 사본** 만들기 용도
- S3 Glacier : 저렴한 객체 스토리지로 사용 목적은 **아카이브**나 **백업**을 위한 클래스. **스토리지당** 비용과 **검색 건당** 비용이 발생. 3가지 클래스가 존재
  - S3 Glacier Instant Retrieval : **밀리초** 단위로 검색, **분기당 한 번** 액세스하는 데이터에 적합하고 **최소** 스토리지 **기간**은 **90일**이다.
  - S3 Glacier Flexible Retrieval : 3개의 tier가 존재하고 최소 스토리지 기간은 90일
    - Expedited : 데이터 검색에 1~5분 정도 걸린다.
    - Standard : 3~5 시간이 걸린다.
    - Bulk : 5~12 시간이 걸린다. **무료!**
  - S3 General Deep Archive : 장기 보관용 스토리지, 2개의 tier가 존재. 검색에 시간이 오래 걸리지만 비용이 제일 저렴하다. 최소 스토리지 기간은 **180**일
    - Standard : 검색에 12시간 대기
    - Bulk : 48시간 대기
- Intelligent Tiering : 액세스 패턴에 따라 객체를 액세스 계증 간 이동시킬 수 있다. 다만 월별 객체 모니터링 비용과 자동 이동 비용이 발생한다
  - Frequent Access tier : 기본 티어
  - Infrequent Access tier : 30일 동안 액세스하지 않는 객체
  - Archive Instant Access tier : 90일 동안 액세스하지 않는 객체
  - Archive Access tier (optional) : 90~700+ 동안 액세스 하지 않는 객체
  - Deep Archive Access tier (optional) : 180~700+ 동안 액세스 하지 않는 객체
